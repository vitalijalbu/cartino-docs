# Notifications System

Laravel's powerful Notifications system is integrated into Cartino to send multi-channel notifications to customers and admins about orders, shipments, promotions, and more.

## Introduction

Notifications in Cartino can be sent via:
- ðŸ“§ **Email** - Transactional emails via SMTP, Mailgun, etc.
- ðŸ’¬ **SMS** - Text messages via Twilio, Vonage
- ðŸ“± **Database** - In-app notifications stored in database
- ðŸ”” **Slack** - Team notifications to Slack channels
- ðŸ“² **Push** - Mobile push notifications (via FCM, APNs)
- ðŸŒ **Custom Channels** - Build your own (Telegram, WhatsApp, etc.)

## Creating Notifications

### Generate Notification Class

```bash
php artisan make:notification OrderPlacedNotification
```

This creates `app/Notifications/OrderPlacedNotification.php`:

```php
namespace App\Notifications;

use Illuminate\Notifications\Notification;
use Illuminate\Notifications\Messages\MailMessage;

class OrderPlacedNotification extends Notification
{
    public function via($notifiable): array
    {
        return ['mail', 'database'];
    }

    public function toMail($notifiable): MailMessage
    {
        return (new MailMessage)
            ->subject('Order Confirmation')
            ->line('Thank you for your order!')
            ->action('View Order', url('/orders/123'))
            ->line('We will notify you when it ships.');
    }

    public function toArray($notifiable): array
    {
        return [
            'order_id' => $this->order->id,
            'amount' => $this->order->total,
        ];
    }
}
```

### Full Example: Order Notification

```php
namespace App\Notifications;

use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Notifications\Notification;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;

class OrderPlacedNotification extends Notification implements ShouldQueue
{
    use Queueable;

    public function __construct(
        public Order $order
    ) {}

    /**
     * Determine which channels to use
     */
    public function via($notifiable): array
    {
        // Use customer preferences
        $channels = ['database'];

        if ($notifiable->email_notifications) {
            $channels[] = 'mail';
        }

        if ($notifiable->sms_notifications) {
            $channels[] = 'vonage'; // SMS
        }

        return $channels;
    }

    /**
     * Email notification
     */
    public function toMail($notifiable): MailMessage
    {
        return (new MailMessage)
            ->subject("Order #{$this->order->number} Confirmed")
            ->greeting("Hello {$notifiable->name}!")
            ->line("Your order has been received and is being processed.")
            ->line("**Order Number:** {$this->order->number}")
            ->line("**Total:** " . money($this->order->total))
            ->action('View Order Details', route('orders.show', $this->order))
            ->line('Thank you for shopping with us!');
    }

    /**
     * Database notification
     */
    public function toArray($notifiable): array
    {
        return [
            'type' => 'order_placed',
            'order_id' => $this->order->id,
            'order_number' => $this->order->number,
            'total' => $this->order->total,
            'items_count' => $this->order->items->count(),
            'message' => "Your order #{$this->order->number} has been placed successfully.",
        ];
    }

    /**
     * SMS notification (Vonage)
     */
    public function toVonage($notifiable)
    {
        return (new \Illuminate\Notifications\Messages\VonageMessage)
            ->content("Your order #{$this->order->number} has been confirmed! Total: " . money($this->order->total));
    }
}
```

## Sending Notifications

### Send to Single User

```php
use App\Notifications\OrderPlacedNotification;

// Using Notifiable trait
$customer->notify(new OrderPlacedNotification($order));
```

### Send to Multiple Users

```php
use Illuminate\Support\Facades\Notification;

// Send to collection
$customers = Customer::where('vip', true)->get();
Notification::send($customers, new PromoNotification($promo));
```

### Send Anonymously

```php
use Illuminate\Support\Facades\Notification;

// Send to arbitrary email (no user model)
Notification::route('mail', '[email protected]')
    ->notify(new InvoiceNotification($invoice));
```

## Notifiable Model

Make models notifiable by using the `Notifiable` trait:

```php
namespace App\Models;

use Illuminate\Notifications\Notifiable;

class Customer extends Model
{
    use Notifiable;

    /**
     * Route notifications for email channel
     */
    public function routeNotificationForMail($notification)
    {
        // Use customer's email
        return $this->email;
    }

    /**
     * Route notifications for SMS
     */
    public function routeNotificationForVonage($notification)
    {
        return $this->phone_number;
    }

    /**
     * Route notifications for Slack
     */
    public function routeNotificationForSlack($notification)
    {
        return $this->slack_webhook_url;
    }
}
```

## Notification Channels

### Email Channel

Already covered above. Use `MailMessage`:

```php
public function toMail($notifiable): MailMessage
{
    return (new MailMessage)
        ->from('[email protected]', 'Cartino Store')
        ->subject('Your order is ready')
        ->markdown('emails.orders.ready', [
            'order' => $this->order,
            'customer' => $notifiable,
        ]);
}
```

### Database Channel

Store notifications in database for in-app notifications:

```php
public function toArray($notifiable): array
{
    return [
        'title' => 'Order Shipped',
        'message' => "Your order #{$this->order->number} has been shipped!",
        'action_url' => route('orders.show', $this->order),
        'icon' => 'truck',
    ];
}
```

#### Retrieving Database Notifications

```php
// Get all notifications
$notifications = $customer->notifications;

// Unread only
$unread = $customer->unreadNotifications;

// Mark as read
$customer->unreadNotifications->markAsRead();

// Mark specific as read
$notification = $customer->notifications()->find($id);
$notification->markAsRead();
```

#### API Endpoint Example

```php
// NotificationController.php
public function index(Request $request)
{
    $notifications = $request->user()->notifications()
        ->latest()
        ->paginate(20);

    return response()->json($notifications);
}

public function markAsRead(Request $request, $id)
{
    $notification = $request->user()
        ->notifications()
        ->findOrFail($id);

    $notification->markAsRead();

    return response()->json(['message' => 'Notification marked as read']);
}

public function markAllAsRead(Request $request)
{
    $request->user()->unreadNotifications->markAsRead();

    return response()->json(['message' => 'All notifications marked as read']);
}
```

### SMS Channel (Vonage)

Install Vonage channel:

```bash
composer require laravel/vonage-notification-channel
```

Configure in `.env`:

```env
VONAGE_KEY=your-api-key
VONAGE_SECRET=your-api-secret
VONAGE_SMS_FROM=YourStore
```

Use in notification:

```php
use Illuminate\Notifications\Messages\VonageMessage;

public function toVonage($notifiable)
{
    return (new VonageMessage)
        ->content("Hi {$notifiable->name}, your order #{$this->order->number} is on its way!")
        ->unicode(); // Support emojis
}
```

### Slack Channel

Configure webhook in `.env`:

```env
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/YOUR/WEBHOOK/URL
```

Use in notification:

```php
use Illuminate\Notifications\Messages\SlackMessage;

public function toSlack($notifiable)
{
    return (new SlackMessage)
        ->from('Cartino Bot', ':shopping_cart:')
        ->to('#sales')
        ->content("New order placed!")
        ->attachment(function ($attachment) {
            $attachment->title("Order #{$this->order->number}")
                ->fields([
                    'Customer' => $this->order->customer->name,
                    'Total' => money($this->order->total),
                    'Items' => $this->order->items->count(),
                ])
                ->action('View Order', route('admin.orders.show', $this->order));
        });
}
```

## Queued Notifications

### Make Notification Queueable

```php
class OrderPlacedNotification extends Notification implements ShouldQueue
{
    use Queueable;

    // Notification will be queued automatically
}
```

### Control Queue Behavior

```php
public function __construct(Order $order)
{
    $this->order = $order;

    // Custom queue
    $this->onQueue('notifications');

    // Custom connection
    $this->onConnection('redis');

    // Delay
    $this->delay(now()->addMinutes(5));
}
```

### Send Immediately (Bypass Queue)

```php
// Even if notification implements ShouldQueue
$customer->notifyNow(new UrgentNotification($data));
```

## On-Demand Notifications

Send notifications without a notifiable model:

```php
use Illuminate\Support\Facades\Notification;

Notification::route('mail', '[email protected]')
    ->route('vonage', '+1234567890')
    ->notify(new InvoiceNotification($invoice));
```

## Conditional Notifications

### Skip Notification Based on Logic

```php
public function via($notifiable): array
{
    // Don't notify if user disabled notifications
    if (!$notifiable->wants_notifications) {
        return [];
    }

    // VIP customers get SMS
    if ($notifiable->is_vip) {
        return ['mail', 'vonage', 'database'];
    }

    return ['mail', 'database'];
}
```

### shouldSend Method

```php
public function shouldSend($notifiable, $channel): bool
{
    // Don't send email if order is below $10
    if ($channel === 'mail' && $this->order->total < 1000) {
        return false;
    }

    return true;
}
```

## Cartino Built-in Notifications

### Order Notifications

```php
namespace App\Notifications\Order;

// Order lifecycle notifications
OrderPlacedNotification         // Order confirmed
OrderProcessingNotification     // Order is being prepared
OrderShippedNotification        // Order shipped with tracking
OrderDeliveredNotification      // Order delivered
OrderCancelledNotification      // Order cancelled
OrderRefundedNotification       // Order refunded
```

### Customer Notifications

```php
namespace App\Notifications\Customer;

WelcomeNotification            // Account created
PasswordResetNotification      // Reset password link
EmailVerificationNotification  // Verify email
AccountUpdatedNotification     // Profile changed
```

### Inventory Notifications

```php
namespace App\Notifications\Inventory;

LowStockNotification          // Product low in stock (admin)
OutOfStockNotification        // Product out of stock (admin)
BackInStockNotification       // Product available again (customer)
```

### Marketing Notifications

```php
namespace App\Notifications\Marketing;

AbandonedCartNotification     // Cart abandoned
WishlistItemOnSaleNotification // Wishlist item discounted
NewProductNotification        // New product launch
PromoCodeNotification         // Exclusive promo code
```

## Event-Driven Notifications

Trigger notifications from events:

```php
// app/Events/OrderShipped.php
namespace App\Events;

class OrderShipped
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public Order $order
    ) {}
}
```

```php
// app/Listeners/SendOrderShippedNotification.php
namespace App\Listeners;

use App\Events\OrderShipped;
use App\Notifications\OrderShippedNotification;

class SendOrderShippedNotification
{
    public function handle(OrderShipped $event): void
    {
        $event->order->customer->notify(
            new OrderShippedNotification($event->order)
        );

        // Also notify admin
        $admins = User::role('admin')->get();
        Notification::send($admins, new AdminOrderShippedNotification($event->order));
    }
}
```

Register in `EventServiceProvider`:

```php
protected $listen = [
    OrderShipped::class => [
        SendOrderShippedNotification::class,
    ],
];
```

## Custom Notification Channels

### Create Custom Channel

```php
namespace App\Notifications\Channels;

use Illuminate\Notifications\Notification;

class TelegramChannel
{
    public function send($notifiable, Notification $notification)
    {
        $message = $notification->toTelegram($notifiable);

        // Send via Telegram Bot API
        Http::post("https://api.telegram.org/bot{$this->token}/sendMessage", [
            'chat_id' => $notifiable->telegram_chat_id,
            'text' => $message->content,
            'parse_mode' => 'Markdown',
        ]);
    }
}
```

### Use Custom Channel

```php
public function via($notifiable): array
{
    return [TelegramChannel::class];
}

public function toTelegram($notifiable)
{
    return (new TelegramMessage)
        ->content("ðŸ›’ New order #{$this->order->number}!")
        ->button('View Order', route('orders.show', $this->order));
}
```

## Notification Preferences

Allow customers to manage notification preferences:

### Database Schema

```php
Schema::table('customers', function (Blueprint $table) {
    $table->json('notification_preferences')->nullable();
});
```

### Model Method

```php
class Customer extends Model
{
    use Notifiable;

    protected $casts = [
        'notification_preferences' => 'array',
    ];

    public function wantsNotification(string $type, string $channel): bool
    {
        $preferences = $this->notification_preferences ?? [];

        return $preferences[$type][$channel] ?? true;
    }
}
```

### Check in Notification

```php
public function via($notifiable): array
{
    $channels = [];

    if ($notifiable->wantsNotification('order_updates', 'email')) {
        $channels[] = 'mail';
    }

    if ($notifiable->wantsNotification('order_updates', 'sms')) {
        $channels[] = 'vonage';
    }

    $channels[] = 'database'; // Always store in database

    return $channels;
}
```

### Preferences Form

```vue
<template>
  <form @submit.prevent="save">
    <h3>Email Notifications</h3>
    <label>
      <input type="checkbox" v-model="preferences.order_updates.email" />
      Order updates
    </label>
    <label>
      <input type="checkbox" v-model="preferences.promotions.email" />
      Promotions
    </label>

    <h3>SMS Notifications</h3>
    <label>
      <input type="checkbox" v-model="preferences.order_updates.sms" />
      Order updates
    </label>

    <button type="submit">Save Preferences</button>
  </form>
</template>

<script setup>
import { ref } from 'vue'

const preferences = ref({
  order_updates: { email: true, sms: false },
  promotions: { email: true, sms: false },
  account: { email: true, sms: false },
})

const save = async () => {
  await axios.post('/customer/notification-preferences', preferences.value)
}
</script>
```

## Testing Notifications

### Fake Notifications

```php
use Illuminate\Support\Facades\Notification;

test('order placed sends notification', function () {
    Notification::fake();

    $order = Order::factory()->create();

    // Trigger notification
    $order->customer->notify(new OrderPlacedNotification($order));

    // Assert notification was sent
    Notification::assertSentTo(
        $order->customer,
        OrderPlacedNotification::class,
        function ($notification) use ($order) {
            return $notification->order->id === $order->id;
        }
    );
});
```

### Assert Not Sent

```php
Notification::assertNotSentTo($customer, OrderCancelledNotification::class);
```

### Assert Sent Times

```php
Notification::assertSentTimes(PromoNotification::class, 100);
```

### Test Specific Channel

```php
test('vip customers receive sms', function () {
    Notification::fake();

    $vipCustomer = Customer::factory()->vip()->create();

    $vipCustomer->notify(new OrderPlacedNotification($order));

    Notification::assertSentTo($vipCustomer, function ($notification, $channels) {
        return in_array('vonage', $channels);
    });
});
```

## Admin Panel Integration

### Notification Center Component

```vue
<template>
  <div class="notification-center">
    <button @click="toggleDropdown" class="relative">
      <BellIcon class="w-6 h-6" />
      <span v-if="unreadCount > 0" class="badge">{{ unreadCount }}</span>
    </button>

    <div v-if="isOpen" class="dropdown">
      <div class="header">
        <h3>Notifications</h3>
        <button @click="markAllAsRead">Mark all read</button>
      </div>

      <div class="notifications-list">
        <div
          v-for="notification in notifications"
          :key="notification.id"
          :class="['notification-item', { unread: !notification.read_at }]"
          @click="handleClick(notification)"
        >
          <div class="icon">{{ getIcon(notification.type) }}</div>
          <div class="content">
            <p class="title">{{ notification.data.title }}</p>
            <p class="message">{{ notification.data.message }}</p>
            <span class="time">{{ formatTime(notification.created_at) }}</span>
          </div>
        </div>
      </div>

      <a href="/notifications" class="view-all">View All Notifications</a>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { BellIcon } from '@heroicons/vue/24/outline'

const notifications = ref([])
const isOpen = ref(false)

const unreadCount = computed(() => {
  return notifications.value.filter(n => !n.read_at).length
})

const fetchNotifications = async () => {
  const response = await axios.get('/api/notifications')
  notifications.value = response.data
}

const markAllAsRead = async () => {
  await axios.post('/api/notifications/mark-all-read')
  notifications.value.forEach(n => n.read_at = new Date())
}

const handleClick = async (notification) => {
  if (!notification.read_at) {
    await axios.post(`/api/notifications/${notification.id}/read`)
    notification.read_at = new Date()
  }

  if (notification.data.action_url) {
    window.location.href = notification.data.action_url
  }
}

const getIcon = (type) => {
  const icons = {
    order_placed: 'ðŸ›’',
    order_shipped: 'ðŸ“¦',
    low_stock: 'âš ï¸',
    new_customer: 'ðŸ‘¤',
  }
  return icons[type] || 'ðŸ””'
}

onMounted(() => {
  fetchNotifications()

  // Poll for new notifications every 30 seconds
  setInterval(fetchNotifications, 30000)
})
</script>
```

## Performance Optimization

### Queue Notifications

```php
// Automatically queued
class OrderPlacedNotification extends Notification implements ShouldQueue
{
    use Queueable;
}
```

### Batch Notifications

```php
// Send to 1000 customers efficiently
$customers = Customer::where('subscribed', true)->get();

Notification::send($customers, new NewsletterNotification($newsletter));
```

### Eager Load Notifiable

```php
// Avoid N+1 queries
$orders = Order::with('customer')->get();

foreach ($orders as $order) {
    $order->customer->notify(new OrderShippedNotification($order));
}
```

## Best Practices

### 1. Keep Notifications Focused

```php
// âœ… Good: Single purpose
class OrderShippedNotification extends Notification {}

// âŒ Bad: Multiple purposes
class OrderNotification extends Notification {} // Too generic
```

### 2. Use Markdown for Emails

```php
public function toMail($notifiable): MailMessage
{
    return (new MailMessage)
        ->markdown('emails.orders.shipped', [
            'order' => $this->order,
            'trackingUrl' => $this->trackingUrl,
        ]);
}
```

### 3. Make Actionable

```php
->action('Track Your Order', $this->trackingUrl)
```

### 4. Test Thoroughly

```php
test('notification contains order details', function () {
    $order = Order::factory()->create();
    $notification = new OrderPlacedNotification($order);

    $mail = $notification->toMail($order->customer);

    expect($mail->subject)->toContain($order->number);
});
```

### 5. Respect User Preferences

Always check notification preferences before sending.

## Troubleshooting

### Notifications Not Sending

```bash
# Check queue is running
php artisan queue:work

# Check mail configuration
php artisan config:clear
php artisan config:cache

# Test email
php artisan notification:test [email protected] TestNotification
```

### Database Notifications Table Missing

```bash
php artisan notifications:table
php artisan migrate
```

### Rate Limiting Issues

Configure in `config/mail.php` or use queues to throttle:

```php
public function __construct(Order $order)
{
    $this->order = $order;
    $this->delay(now()->addSeconds(10)); // Throttle
}
```

## Resources

- [Laravel Notifications Documentation](https://laravel.com/docs/notifications)
- [Laravel Vonage Channel](https://laravel.com/docs/notifications#sms-notifications)
- [Custom Notification Channels](https://laravel-notification-channels.com/)
- [Notification Events](https://laravel.com/docs/notifications#notification-events)

## Next Steps

- **[Mail & Mailable â†’](/packages/mailable)** - Learn about email templates
- **[Events & Listeners â†’](/extending/events)** - Trigger notifications from events
- **[API Reference â†’](/api/rest)** - Notification endpoints
