---
title: Backend Extensions
description: Extend Cartino's backend with custom models, services, and APIs.
---

# Backend Extensions

Extend Cartino's backend to add custom functionality, integrate services, and build new features.

## Custom Models

### Creating a Model

Create custom Eloquent models for your business logic:

```php
// app/Extensions/Models/Subscription.php
namespace App\Extensions\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Cartino\Models\Customer;

class Subscription extends Model
{
    protected $fillable = [
        'customer_id',
        'plan_id',
        'status',
        'started_at',
        'ends_at',
        'trial_ends_at',
    ];

    protected $casts = [
        'started_at' => 'datetime',
        'ends_at' => 'datetime',
        'trial_ends_at' => 'datetime',
    ];

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function isActive(): bool
    {
        return $this->status === 'active' 
            && $this->ends_at->isFuture();
    }

    public function cancel(): void
    {
        $this->update(['status' => 'cancelled']);
    }
}
```

### Migration

Create the database migration:

```php
// database/migrations/2025_01_01_000000_create_subscriptions_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('subscriptions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('customer_id')->constrained()->cascadeOnDelete();
            $table->foreignId('plan_id')->constrained()->cascadeOnDelete();
            $table->string('status')->default('active');
            $table->timestamp('started_at');
            $table->timestamp('ends_at')->nullable();
            $table->timestamp('trial_ends_at')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            
            $table->index('status');
            $table->index('ends_at');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('subscriptions');
    }
};
```

## Extending Existing Models

### Using Model Observers

Observe and react to model events:

```php
// app/Observers/OrderObserver.php
namespace App\Observers;

use Cartino\Models\Order;
use App\Services\NotificationService;

class OrderObserver
{
    public function created(Order $order): void
    {
        // Send notification when order is created
        app(NotificationService::class)->orderCreated($order);
    }

    public function updated(Order $order): void
    {
        if ($order->wasChanged('status')) {
            // Handle status change
            app(NotificationService::class)->orderStatusChanged($order);
        }
    }
}
```

Register the observer:

```php
// app/Providers/AppServiceProvider.php
use Cartino\Models\Order;
use App\Observers\OrderObserver;

public function boot(): void
{
    Order::observe(OrderObserver::class);
}
```

### Using Traits

Add functionality via traits:

```php
// app/Extensions/Traits/HasSubscription.php
namespace App\Extensions\Traits;

use App\Extensions\Models\Subscription;
use Illuminate\Database\Eloquent\Relations\HasOne;

trait HasSubscription
{
    public function subscription(): HasOne
    {
        return $this->hasOne(Subscription::class);
    }

    public function isSubscribed(): bool
    {
        return $this->subscription?->isActive() ?? false;
    }

    public function subscribe(string $planId): Subscription
    {
        return $this->subscription()->create([
            'plan_id' => $planId,
            'status' => 'active',
            'started_at' => now(),
        ]);
    }
}
```

Apply to existing models:

```php
// app/Extensions/Models/Customer.php
namespace App\Extensions\Models;

use Cartino\Models\Customer as BaseCustomer;
use App\Extensions\Traits\HasSubscription;

class Customer extends BaseCustomer
{
    use HasSubscription;
}
```

## Custom Controllers

### API Controller

Create custom API endpoints:

```php
// app/Http/Controllers/Api/SubscriptionController.php
namespace App\Http\Controllers\Api;

use App\Extensions\Models\Subscription;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class SubscriptionController extends Controller
{
    public function index(Request $request): JsonResponse
    {
        $subscriptions = Subscription::query()
            ->with('customer')
            ->when($request->status, fn($q, $status) => 
                $q->where('status', $status)
            )
            ->paginate(20);

        return response()->json($subscriptions);
    }

    public function store(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'customer_id' => 'required|exists:customers,id',
            'plan_id' => 'required|exists:plans,id',
            'trial_days' => 'nullable|integer|min:0',
        ]);

        $subscription = Subscription::create([
            ...$validated,
            'started_at' => now(),
            'trial_ends_at' => $validated['trial_days'] 
                ? now()->addDays($validated['trial_days']) 
                : null,
        ]);

        return response()->json($subscription, 201);
    }

    public function cancel(Subscription $subscription): JsonResponse
    {
        $subscription->cancel();

        return response()->json([
            'message' => 'Subscription cancelled successfully'
        ]);
    }
}
```

### Admin Controller

Create admin panel controllers:

```php
// app/Http/Controllers/Admin/SubscriptionController.php
namespace App\Http\Controllers\Admin;

use App\Extensions\Models\Subscription;
use Inertia\Inertia;
use Inertia\Response;

class SubscriptionController extends Controller
{
    public function index(): Response
    {
        return Inertia::render('Subscriptions/Index', [
            'subscriptions' => Subscription::with('customer')
                ->latest()
                ->paginate(20),
        ]);
    }

    public function show(Subscription $subscription): Response
    {
        return Inertia::render('Subscriptions/Show', [
            'subscription' => $subscription->load('customer'),
        ]);
    }
}
```

## Custom Routes

### API Routes

```php
// routes/api.php
use App\Http\Controllers\Api\SubscriptionController;

Route::prefix('subscriptions')->group(function () {
    Route::get('/', [SubscriptionController::class, 'index']);
    Route::post('/', [SubscriptionController::class, 'store']);
    Route::post('/{subscription}/cancel', [SubscriptionController::class, 'cancel']);
});
```

### Admin Routes

```php
// routes/web.php
use App\Http\Controllers\Admin\SubscriptionController;

Route::middleware(['auth', 'admin'])->group(function () {
    Route::resource('subscriptions', SubscriptionController::class);
});
```

## Services

Create reusable service classes:

```php
// app/Services/SubscriptionService.php
namespace App\Services;

use App\Extensions\Models\Subscription;
use Cartino\Models\Customer;
use Carbon\Carbon;

class SubscriptionService
{
    public function createSubscription(
        Customer $customer,
        string $planId,
        ?int $trialDays = null
    ): Subscription {
        return $customer->subscription()->create([
            'plan_id' => $planId,
            'status' => 'active',
            'started_at' => now(),
            'trial_ends_at' => $trialDays ? now()->addDays($trialDays) : null,
        ]);
    }

    public function renewSubscription(Subscription $subscription): void
    {
        $subscription->update([
            'ends_at' => now()->addMonth(),
            'status' => 'active',
        ]);
    }

    public function getExpiringSubscriptions(int $days = 7): Collection
    {
        return Subscription::query()
            ->where('status', 'active')
            ->whereBetween('ends_at', [
                now(),
                now()->addDays($days),
            ])
            ->get();
    }
}
```

Register in service provider:

```php
// app/Providers/AppServiceProvider.php
public function register(): void
{
    $this->app->singleton(SubscriptionService::class);
}
```

## Events & Listeners

### Custom Events

```php
// app/Events/SubscriptionCreated.php
namespace App\Events;

use App\Extensions\Models\Subscription;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class SubscriptionCreated
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public Subscription $subscription
    ) {}
}
```

### Event Listeners

```php
// app/Listeners/SendSubscriptionWelcomeEmail.php
namespace App\Listeners;

use App\Events\SubscriptionCreated;
use Illuminate\Support\Facades\Mail;

class SendSubscriptionWelcomeEmail
{
    public function handle(SubscriptionCreated $event): void
    {
        Mail::to($event->subscription->customer->email)
            ->send(new SubscriptionWelcomeMail($event->subscription));
    }
}
```

Register in EventServiceProvider:

```php
protected $listen = [
    SubscriptionCreated::class => [
        SendSubscriptionWelcomeEmail::class,
    ],
];
```

## Artisan Commands

Create custom commands:

```php
// app/Console/Commands/CheckExpiredSubscriptions.php
namespace App\Console\Commands;

use App\Extensions\Models\Subscription;
use Illuminate\Console\Command;

class CheckExpiredSubscriptions extends Command
{
    protected $signature = 'subscriptions:check-expired';
    protected $description = 'Check and expire subscriptions';

    public function handle(): int
    {
        $expired = Subscription::query()
            ->where('status', 'active')
            ->where('ends_at', '<=', now())
            ->get();

        foreach ($expired as $subscription) {
            $subscription->update(['status' => 'expired']);
            $this->info("Expired subscription {$subscription->id}");
        }

        $this->info("Processed {$expired->count()} subscriptions");

        return self::SUCCESS;
    }
}
```

## Middleware

Create custom middleware:

```php
// app/Http/Middleware/RequireSubscription.php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class RequireSubscription
{
    public function handle(Request $request, Closure $next)
    {
        if (!$request->user()->isSubscribed()) {
            return redirect()->route('subscribe');
        }

        return $next($request);
    }
}
```

Register in Kernel:

```php
protected $middlewareAliases = [
    'subscribed' => \App\Http\Middleware\RequireSubscription::class,
];
```

## Testing

Test your extensions:

```php
// tests/Feature/SubscriptionTest.php
namespace Tests\Feature;

use Tests\TestCase;
use App\Extensions\Models\Subscription;
use Cartino\Models\Customer;

class SubscriptionTest extends TestCase
{
    public function test_customer_can_subscribe(): void
    {
        $customer = Customer::factory()->create();
        
        $response = $this->postJson('/api/subscriptions', [
            'customer_id' => $customer->id,
            'plan_id' => 1,
        ]);

        $response->assertStatus(201);
        $this->assertDatabaseHas('subscriptions', [
            'customer_id' => $customer->id,
        ]);
    }

    public function test_subscription_can_be_cancelled(): void
    {
        $subscription = Subscription::factory()->create();
        
        $response = $this->postJson(
            "/api/subscriptions/{$subscription->id}/cancel"
        );

        $response->assertOk();
        $this->assertEquals('cancelled', $subscription->fresh()->status);
    }
}
```

## Best Practices

::callout{icon="i-lucide-check-circle" color="green"}
**Do's**
- Use service providers for organization
- Follow Laravel conventions
- Write comprehensive tests
- Use events for loosely coupled code
- Document your extensions
::

::callout{icon="i-lucide-alert-circle" color="amber"}
**Don'ts**
- Don't modify core Cartino files
- Avoid tight coupling
- Don't skip validation
- Avoid hardcoded values
::

## Next Steps

- [Frontend Extensions](/extending/frontend) - Extend the admin UI
- [Events & Hooks](/extending/events) - Hook into Cartino's events
- [Building Addons](/extending/addons) - Create distributable packages
