---
title: Events & Hooks
description: Hook into Cartino's event system to extend functionality.
---

# Events & Hooks

Cartino uses Laravel's event system to provide hooks for extending functionality without modifying core code.

## Available Events

### Order Events

```php
namespace Cartino\Events\Order;

// Order Created
OrderCreated::class
// Dispatched when: New order is created
// Payload: Order $order

// Order Updated
OrderUpdated::class
// Dispatched when: Order is updated
// Payload: Order $order, array $changes

// Order Status Changed
OrderStatusChanged::class
// Dispatched when: Order status changes
// Payload: Order $order, string $oldStatus, string $newStatus

// Order Cancelled
OrderCancelled::class
// Dispatched when: Order is cancelled
// Payload: Order $order, string $reason

// Order Fulfilled
OrderFulfilled::class
// Dispatched when: Order is completely fulfilled
// Payload: Order $order

// Order Refunded
OrderRefunded::class
// Dispatched when: Order is refunded
// Payload: Order $order, float $amount
```

### Product Events

```php
namespace Cartino\Events\Product;

// Product Created
ProductCreated::class
// Payload: Product $product

// Product Updated
ProductUpdated::class
// Payload: Product $product, array $changes

// Product Deleted
ProductDeleted::class
// Payload: int $productId

// Variant Price Changed
VariantPriceChanged::class
// Payload: ProductVariant $variant, float $oldPrice, float $newPrice

// Stock Level Changed
StockLevelChanged::class
// Payload: InventoryItem $item, int $oldLevel, int $newLevel
```

### Customer Events

```php
namespace Cartino\Events\Customer;

// Customer Registered
CustomerRegistered::class
// Payload: Customer $customer

// Customer Updated
CustomerUpdated::class
// Payload: Customer $customer

// Customer Group Changed
CustomerGroupChanged::class
// Payload: Customer $customer, CustomerGroup $newGroup
```

### Cart Events

```php
namespace Cartino\Events\Cart;

// Item Added to Cart
CartItemAdded::class
// Payload: Cart $cart, CartItem $item

// Item Removed from Cart
CartItemRemoved::class
// Payload: Cart $cart, int $itemId

// Cart Updated
CartUpdated::class
// Payload: Cart $cart

// Cart Converted to Order
CartConverted::class
// Payload: Cart $cart, Order $order
```

## Listening to Events

### Create a Listener

```php
// app/Listeners/SendOrderConfirmationEmail.php
namespace App\Listeners;

use Cartino\Events\Order\OrderCreated;
use Illuminate\Support\Facades\Mail;
use App\Mail\OrderConfirmationMail;

class SendOrderConfirmationEmail
{
    public function handle(OrderCreated $event): void
    {
        Mail::to($event->order->customer->email)
            ->send(new OrderConfirmationMail($event->order));
    }
}
```

### Register Listener

```php
// app/Providers/EventServiceProvider.php
use Cartino\Events\Order\OrderCreated;
use App\Listeners\SendOrderConfirmationEmail;

protected $listen = [
    OrderCreated::class => [
        SendOrderConfirmationEmail::class,
    ],
];
```

### Auto-Discovery

Laravel can auto-discover listeners:

```php
// app/Listeners/Order/
// ├── SendOrderConfirmationEmail.php
// ├── UpdateInventory.php
// └── NotifyWarehouse.php

// These will be auto-discovered if placed in app/Listeners
```

## Event Subscribers

Group related event handlers:

```php
// app/Listeners/OrderEventSubscriber.php
namespace App\Listeners;

use Cartino\Events\Order;
use Illuminate\Events\Dispatcher;

class OrderEventSubscriber
{
    public function handleOrderCreated(Order\OrderCreated $event): void
    {
        // Send confirmation email
        // Update analytics
        // Notify warehouse
    }

    public function handleOrderStatusChanged(Order\OrderStatusChanged $event): void
    {
        // Update customer
        // Log status change
    }

    public function handleOrderCancelled(Order\OrderCancelled $event): void
    {
        // Process refund
        // Restore inventory
        // Notify customer
    }

    public function subscribe(Dispatcher $events): array
    {
        return [
            Order\OrderCreated::class => 'handleOrderCreated',
            Order\OrderStatusChanged::class => 'handleOrderStatusChanged',
            Order\OrderCancelled::class => 'handleOrderCancelled',
        ];
    }
}
```

Register subscriber:

```php
// app/Providers/EventServiceProvider.php
protected $subscribe = [
    OrderEventSubscriber::class,
];
```

## Creating Custom Events

```php
// app/Events/SubscriptionRenewed.php
namespace App\Events;

use App\Models\Subscription;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class SubscriptionRenewed
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public Subscription $subscription,
        public bool $autoRenewed = false
    ) {}
}
```

Dispatch event:

```php
use App\Events\SubscriptionRenewed;

$subscription->renew();

event(new SubscriptionRenewed($subscription, true));
```

## Queued Listeners

Process events asynchronously:

```php
namespace App\Listeners;

use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class ProcessLargeExport implements ShouldQueue
{
    use InteractsWithQueue;

    public int $tries = 3;
    public int $timeout = 300;

    public function handle(ExportRequested $event): void
    {
        // Time-consuming export logic
    }

    public function failed(ExportRequested $event, \Throwable $exception): void
    {
        // Handle failure
    }
}
```

## Conditional Listeners

Only execute under certain conditions:

```php
class NotifyHighValueCustomers
{
    public function handle(OrderCreated $event): void
    {
        if ($event->order->total < 1000) {
            return; // Skip for orders under $1000
        }

        // Send VIP notification
    }
}
```

## Event Priority

Control listener execution order:

```php
// app/Providers/EventServiceProvider.php
protected $listen = [
    OrderCreated::class => [
        ValidateInventory::class => 10,      // Runs first
        SendConfirmationEmail::class => 5,   // Runs second
        UpdateAnalytics::class => 0,         // Runs last
    ],
];
```

## Hooks via Model Observers

Alternative to events for model-specific logic:

```php
// app/Observers/ProductObserver.php
namespace App\Observers;

use Cartino\Models\Product;

class ProductObserver
{
    public function creating(Product $product): void
    {
        // Before product is created
        $product->slug = str($product->title)->slug();
    }

    public function created(Product $product): void
    {
        // After product is created
        cache()->forget('products_list');
    }

    public function updating(Product $product): void
    {
        // Before product is updated
    }

    public function updated(Product $product): void
    {
        // After product is updated
        if ($product->wasChanged('status')) {
            // Status changed
        }
    }

    public function deleting(Product $product): void
    {
        // Before product is deleted
    }

    public function deleted(Product $product): void
    {
        // After product is deleted
    }
}
```

Register observer:

```php
// app/Providers/AppServiceProvider.php
use Cartino\Models\Product;
use App\Observers\ProductObserver;

public function boot(): void
{
    Product::observe(ProductObserver::class);
}
```

## Webhook Events

Trigger webhooks from events:

```php
// app/Listeners/TriggerWebhook.php
namespace App\Listeners;

use Illuminate\Support\Facades\Http;

class TriggerWebhook
{
    public function handle(OrderCreated $event): void
    {
        $webhooks = Webhook::where('event', 'order.created')
            ->where('active', true)
            ->get();

        foreach ($webhooks as $webhook) {
            Http::post($webhook->url, [
                'event' => 'order.created',
                'data' => $event->order->toArray(),
            ]);
        }
    }
}
```

## Testing Events

```php
// tests/Feature/OrderEventTest.php
namespace Tests\Feature;

use Tests\TestCase;
use Illuminate\Support\Facades\Event;
use Cartino\Events\Order\OrderCreated;

class OrderEventTest extends TestCase
{
    public function test_order_created_event_dispatched(): void
    {
        Event::fake();

        $order = Order::factory()->create();

        Event::assertDispatched(OrderCreated::class, function ($event) use ($order) {
            return $event->order->id === $order->id;
        });
    }

    public function test_confirmation_email_sent(): void
    {
        Mail::fake();

        $order = Order::factory()->create();

        Mail::assertSent(OrderConfirmationMail::class, function ($mail) use ($order) {
            return $mail->order->id === $order->id;
        });
    }
}
```

## Common Use Cases

### Inventory Management

```php
class UpdateInventoryOnOrder
{
    public function handle(OrderCreated $event): void
    {
        foreach ($event->order->items as $item) {
            $item->variant->inventory->decrement('quantity', $item->quantity);
            
            // Create stock movement
            StockMovement::create([
                'inventory_item_id' => $item->variant->inventory_item_id,
                'quantity' => -$item->quantity,
                'type' => 'sale',
                'reference_type' => Order::class,
                'reference_id' => $event->order->id,
            ]);
        }
    }
}
```

### Loyalty Points

```php
class AwardLoyaltyPoints
{
    public function handle(OrderFulfilled $event): void
    {
        $customer = $event->order->customer;
        
        if ($customer->fidelityCard) {
            $points = (int) ($event->order->total / 10);
            
            $customer->fidelityCard->transactions()->create([
                'type' => 'earn',
                'points' => $points,
                'description' => "Order #{$event->order->number}",
            ]);
        }
    }
}
```

### Analytics

```php
class TrackOrderAnalytics
{
    public function handle(OrderCreated $event): void
    {
        Analytics::track('order_created', [
            'order_id' => $event->order->id,
            'total' => $event->order->total,
            'items_count' => $event->order->items->count(),
            'customer_id' => $event->order->customer_id,
        ]);
    }
}
```

## Best Practices

::callout{icon="i-lucide-check-circle" color="green"}
**Do's**
- Use queued listeners for time-consuming tasks
- Keep listeners focused on single responsibility
- Use events for loose coupling between modules
- Test event dispatching and listener execution
::

::callout{icon="i-lucide-alert-circle" color="amber"}
**Don'ts**
- Don't perform heavy operations in sync listeners
- Avoid circular event dispatching
- Don't swallow exceptions in listeners
- Avoid coupling listeners to specific implementations
::

## Next Steps

- [Backend Extensions](/extending/backend) - Build custom backend logic
- [Building Addons](/extending/addons) - Package event listeners as addons
